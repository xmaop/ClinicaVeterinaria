
/*
Copyright (C) (2011-2012) Selvakumar Arumugam
*/
(function ($) {

    $.fn.diagWareHouse = function (options) {

        var defaults = {
            tablename: '_table',
            showHead: true,
            showNivel: true,
            showShelf: true,
            columns: 0,
            shelfs: 0,
            nivels: 0
        };

        options = $.extend({}, defaults, options);

        function addNivel(shelf, nivel) {
           
            return $row;
        }

        return this.each(function () {
            var structure = {
                head: null,
                footer: null,
                body: null,
                tableTmpl: function () {
                    return '<table />';
                },
                nivelTmpl: function () {
                }
            };

            var $table = $(structure.tableTmpl());

            structure.head = $('<thead />');
          
            if (options.columns > 0) {

                structure.head.append($('<tr />'));

                if (options.showNivel) {
                    structure.head.find('tr').append($('<td />').text(' ').addClass("ui-ExcelTable-Th-heading"));
                }
                for (c = 1; c <= options.columns; c++) {
                    structure.head.find('tr').append($('<td />').text(c).addClass("ui-ExcelTable-Th"));
                }
                if (options.showShelf) {
                    structure.head.find('tr').append($('<td />').text(' ').addClass("ui-ExcelTable-Th-heading"));
                }

                structure.footer = $('<footer />');

                structure.body = $('<tbody />');

                for (s = 1; s <= options.shelfs; s++) {
                    for (n = options.nivels; n > 0; n--) {
                        structure.body.append($('<tr />'));
                        if (options.showNivel) {
                            structure.body.find('tr:last').append(
                                $('<td />')
                                    .attr('id', s + '.' + 0 + '.' + n)
                                    .append($('<b/>').text(n))
                                    .addClass("ui-ExcelTable-Td-index")
                            );
                        }
                        for (c = 1; c <= options.columns; c++) {
                            structure.body.find('tr:last').append(
                                $('<td />')
                                    .attr('id', s + '.' + c + '.' + n)
                                    .append(s + '.' + c + '.' + n)
                                    .addClass("ui-ExcelTable-Td")
                            );
                            if (n == 1 && s != options.shelfs) {
                                structure.body.find('tr:last').find('td:last')
                                    .css({ 'border-width': '0px 1px 2px 0px', 'border-bottom-color': 'black' });
                            }

                        }
                        if (options.showShelf) {
                            structure.body.find('tr:last').append(
                                $('<td />')
                                    .attr('id', s + '.' + (options.columns + 1) + '.' + n)
                                    .append($('<b/>').text(s))
                                    .addClass("ui-ExcelTable-Th-heading")
                            );
                        }
                    }
                }

                $table.append(structure.head);

                $table.append(structure.footer);

                $table.append(structure.body);

                $table.attr('id', this.id + options.tablename);

            }

            $(this).append($table);

        });

    };

})(jQuery);
(function ($) {

    $.fn.fxdHdrCol = function (o) {
        var cfg = {
            height: 0,
            width: 0,
            fixedCols: 0,
            includeLast: false,
            colModal: [],
            tableTmpl: function () {
                return '<table />';
            },
            sort: false
        };
        $.extend(cfg, o);

        return this.each(function () {
            var lc = {
                ft_container: null,
                ft_rel_container: null,
                ft_wrapper: null,
                ft_rc: null,
                ft_r: null,
                ft_c: null,
                ft_l: null,
                tableWidth: 0
            };


            // obtiene elemento tplano (table)
            var $this = $(this);

            // asigna estilos basicos
            $this.addClass('ui-widget-header');
            $this.find('tbody tr').addClass('ui-widget-content');

            // crea el contenedor padre ft_container e incluye la tabla 1er nivel
            $this.wrap('<div class="ft_container" />');
            lc.ft_container = $this.parent().css({ width: cfg.width, height: cfg.height });

            // obtiene celdas de la cabecera
            var $ths = $('thead tr', $this).first().find('th');

            // valida sort
            if (cfg.sort && sorttable && cfg.fixedCols == 0) {
                $ths.addClass('fx_sort_bg');
            }

            var $thFirst = $ths.first();
            var $thLast = $ths.last();
            var thSpace = parseInt($thFirst.css('paddingLeft'), 10) + parseInt($thFirst.css('paddingRight'), 10);

            /* configura ancho y alineamiento del array colModal */
            var ct = 0;
            // calcula ancho
            $ths.each(function (i, el) {
                var calcWidth = 0;
                for (var j = 0; j < el.colSpan; j++) {
                    calcWidth += cfg.colModal[ct].width;
                    ct++;
                }
                $(el).css({ width: calcWidth, textAlign: cfg.colModal[ct - 1].align });
                lc.tableWidth += calcWidth + thSpace + ((i == 0) ? 2 : 1);
            });

            // set alineamiento en el body
            //$('tbody', $this).find('tr').each(function (i, el) {
            //    $('td', el).each(function (i, tdel) {
            //        tdel.style.textAlign = cfg.colModal[i].align;
            //    });
            //});
            // establece tamanio 
            $this.width(lc.tableWidth);

            // agrega div relativo e incluye la tabla 2do nivel
            $this.wrap('<div class="ft_rel_container" />');
            lc.ft_rel_container = $this.parent();

            //agrega div con scrollbar e incluye la tabla 3er nivel
            $this.wrap('<div class="ft_scroller" />');
            lc.ft_wrapper = $this.parent().css('width', cfg.width - 5);

            var theadTr = $('thead', $this);
            //clone thead->tr 
            var theadTrClone = theadTr.clone();

            //contruye cabecera full row y agrega a contenedor 2do nivel 
            lc.ft_rel_container
				.prepend($(cfg.tableTmpl(), { 'class': 'ft_r ui-widget-header' })
				.append(theadTrClone));

            //console.log($('.ft_r', lc.ft_rel_container).html());

            //agrega a div cabecera e incluye tabla cabecera a contenedor 3er nivel
            lc.ft_r = $('.ft_r', lc.ft_rel_container);
            lc.ft_r.wrap($('<div />', { 'class': 'ft_rwrapper' }));

            lc.ft_r.width(lc.tableWidth);

            //console.log(cfg.fixedCols);
            //console.log(cfg.includeLast);

            if (cfg.fixedCols > 0) {
                //clone the thead again to construct the 
                theadTrClone = theadTr.clone();
                theadTrClone_Last = theadTr.clone();

                //calculate the actual column's count (support for colspan)					
                var r1c1ColSpan = 0;
                for (var i = 0; i < cfg.fixedCols; i++) {
                    r1c1ColSpan += this.rows[0].cells[i].colSpan;
                }

                //prepare rows/cols for fixed row col section
                var tdct = 0;
                $('tr', theadTrClone).first().find('th').filter(function () {
                    tdct += this.colSpan;
                    return tdct > r1c1ColSpan;
                }).remove();

                //add fixed row col section
                lc.ft_rel_container
					.prepend($(cfg.tableTmpl(), { 'class': 'ft_rc ui-widget-header' })
					.append(theadTrClone));

                //an instance of fixed row column
                lc.ft_rc = $('.ft_rc', lc.ft_rel_container);

                if (cfg.includeLast) {
                    $('tr', theadTrClone_Last).first().find('th:not(:last-child)').remove();
                    lc.ft_rel_container
					.append($(cfg.tableTmpl(), { 'class': 'ft_rc ui-widget-header ft_lrc' })
					.append(theadTrClone_Last));
                }

                //now clone the fixed row column and append tbody for the remaining rows
                lc.ft_c = lc.ft_rc.clone();
                lc.ft_c[0].className = 'ft_c';

                //append tbody
                lc.ft_c.append('<tbody />');

                //append row by row while just keeping the frozen cols
                var ftc_tbody = lc.ft_c.find('tbody');
                $.each($this.find('tbody > tr'), function (idx, el) {
                    var tr = $(el).clone();

                    tdct = 0;
                    tr.find('td').filter(function () {
                        tdct += this.colSpan;
                        return tdct > r1c1ColSpan;
                    }).remove();

                    ftc_tbody.append(tr);
                });

                lc.ft_rc.after(lc.ft_c);
                lc.ft_c.wrap($('<div />', { 'class': 'ft_cwrapper' }));

                var tw = 0;
                for (var i = 0; i < cfg.fixedCols; i++) {
                    tw += $(this.rows[0].cells[i]).outerWidth(true);
                }
                lc.ft_c.add(lc.ft_rc).width(tw);
                lc.ft_c.height($this.outerHeight(true));

                //set height of fixed_rc and fixed_c
                for (var i = 0; i < this.rows.length; i++) {
                    var ch = $(this.rows[i]).outerHeight();
                    var fch = $(lc.ft_c[0].rows[i]).outerHeight(true);

                    ch = (ch > fch) ? ch : fch;

                    if (i < lc.ft_rc[0].rows.length) {
                        $(lc.ft_r[0].rows[i])
							.add(lc.ft_rc[0].rows[i])
							.height(ch);
                    }

                    $(lc.ft_c[0].rows[i])
						.add(this.rows[i])
						.height(ch);
                }

                lc.ft_c
					.parent()
					.css({ height: cfg.height - 17 })
					.width(lc.ft_rc.outerWidth(true) + 1);


                if (cfg.includeLast) {
                    lc.ft_l = $('.ft_lrc', lc.ft_rel_container).clone();
                    lc.ft_l[0].className = 'ft_c';
                    lc.ft_l.append('<tbody />');

                    var ftl_tbody = lc.ft_l.find('tbody');
                    $.each($this.find('tbody > tr'), function (idx, el) {
                        var tr = $(el).clone();
                        tr.find('td:not(:last-child)').remove();
                        ftl_tbody.append(tr);
                    });

                    lc.ft_rc.after(lc.ft_l);
                    lc.ft_l.wrap($('<div />', { 'class': 'ft_lwrapper' }));
                    lc.ft_l
					.parent()
					.css({ height: cfg.height - 17 })
					.width(lc.ft_rc.outerWidth(true) + 1);
                }
            }

            lc.ft_r
				.parent()
				.css({ width: lc.ft_wrapper.width() - 17 });

            if (cfg.includeLast) {
                var position_ftl = $this.outerWidth(true) > $('.ft_rwrapper').outerWidth(true) ? $('.ft_rwrapper').outerWidth(true) : $this.outerWidth(true);

                var calculated_left = position_ftl - lc.ft_rc.outerWidth(true);
                if (lc.ft_wrapper.get(0).scrollHeight <= lc.ft_wrapper.height()) {
                    if (lc.ft_wrapper.get(0).scrollWidth > lc.ft_wrapper.width()) {
                        calculated_left = calculated_left + 17;
                    }
                    else {
                        calculated_left = calculated_left;
                    }
                }
                lc.ft_l
					.parent()
					.css({ left: calculated_left })

                $('.ft_lrc', lc.ft_rel_container).css({ left: calculated_left })

            }

            // fix heigth en caso no tenga necesidad de scrollWidth
            if (lc.ft_wrapper.get(0).scrollWidth <= lc.ft_wrapper.width()) {
                lc.ft_c
					.parent()
					.css({ height: cfg.height + 17 })

                lc.ft_l
                    .parent()
                    .css({ height: cfg.height + 17 })
            }
            
            //events (scroll and resize)
            lc.ft_wrapper.scroll(function () {
                $('#jqContextMenu').hide().next().hide();
                if (cfg.fixedCols > 0) {
                    lc.ft_c.css('top', ($(this).scrollTop() * -1));
                    if (cfg.includeLast) {
                        lc.ft_l.css('top', ($(this).scrollTop() * -1));
                    }
                }
                lc.ft_r.css('left', ($(this).scrollLeft() * -1));
            });

            /*$(window).on('resize', function () {
				lc.ft_r
				.parent()
				.css({width: lc.ft_rel_container.width()- 17});			
			});

            if (cfg.sort && sorttable && cfg.fixedCols == 0) {

                $('table', lc.ft_container).addClass('sorttable');

                sorttable.makeSortable(this);

                var $sortableTh = $('.fx_sort_bg', lc.ft_rel_container);

                $sortableTh.click(function () {
                    var $this = $(this);
                    var isAscSort = $this.hasClass('fx_sort_asc');

                    $sortableTh.removeClass('fx_sort_asc fx_sort_desc');

                    if (isAscSort) {
                        $this.addClass('fx_sort_desc').removeClass('fx_sort_asc');
                    } else {
                        $this.addClass('fx_sort_asc').removeClass('fx_sort_desc');
                    }

                    var idx = $(this).index();

                    sorttable.innerSortFunction.apply(lc.ft_wrapper.find('th').get(idx), []);
                });
            }*/

        });

    };

})(jQuery);

(function ($) {
    var converter = {
        vertical: { x: false, y: true },
        horizontal: { x: true, y: false },
        both: { x: true, y: true },
        x: { x: true, y: false },
        y: { x: false, y: true }
    };

    var options = {
        duration: "fast",
        direction: "both",
        activeanime: false,
    };

    var rootrx = /^(?:html)$/i;

    // gets border dimensions
    var borders = function (domElement, styles) {
        styles = styles || (document.defaultView && document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(domElement, null) : domElement.currentStyle);
        var px = document.defaultView && document.defaultView.getComputedStyle ? true : false;
        var b = {
            top: (parseFloat(px ? styles.borderTopWidth : $.css(domElement, "borderTopWidth")) || 0),
            left: (parseFloat(px ? styles.borderLeftWidth : $.css(domElement, "borderLeftWidth")) || 0),
            bottom: (parseFloat(px ? styles.borderBottomWidth : $.css(domElement, "borderBottomWidth")) || 0),
            right: (parseFloat(px ? styles.borderRightWidth : $.css(domElement, "borderRightWidth")) || 0)
        };
        return {
            top: b.top,
            left: b.left,
            bottom: b.bottom,
            right: b.right,
            vertical: b.top + b.bottom,
            horizontal: b.left + b.right
        };
    };

    var dimensions = function ($element) {
        var win = $(window);
        var isRoot = rootrx.test($element[0].nodeName);
        return {
            border: isRoot ? { top: 0, left: 0, bottom: 0, right: 0 } : borders($element[0]),
            scroll: {
                top: (isRoot ? win : $element).scrollTop(),
                left: (isRoot ? win : $element).scrollLeft()
            },
            scrollbar: {
                right: isRoot ? 0 : $element.innerWidth() - $element[0].clientWidth,
                bottom: isRoot ? 0 : $element.innerHeight() - $element[0].clientHeight
            },
            rect: (function () {
                var r = $element[0].getBoundingClientRect();
                return {
                    top: isRoot ? 0 : r.top,
                    left: isRoot ? 0 : r.left,
                    bottom: isRoot ? $element[0].clientHeight : r.bottom,
                    right: isRoot ? $element[0].clientWidth : r.right
                };
            })()
        };
    };

    $.fn.extend({
        scrollintoview: function (options) {
            /// <summary>Scrolls the first element in the set into view by scrolling its closest scrollable parent.</summary>
            /// <param name="options" type="Object">Additional options that can configure scrolling:
            ///        duration (default: "fast") - jQuery animation speed (can be a duration string or number of milliseconds)
            ///        direction (default: "both") - select possible scrollings ("vertical" or "y", "horizontal" or "x", "both")
            ///        complete (default: none) - a function to call when scrolling completes (called in context of the DOM element being scrolled)
            /// </param>
            /// <return type="jQuery">Returns the same jQuery set that this function was run on.</return>

            options = $.extend({}, options, options);
            options.direction = converter[typeof (options.direction) === "string" && options.direction.toLowerCase()] || converter.both;

            var dirStr = "";
            if (options.direction.x === true) dirStr = "horizontal";
            if (options.direction.y === true) dirStr = dirStr ? "both" : "vertical";

            var el = this.eq(0);
            var scroller = el.closest(":scrollable(" + dirStr + ")");

            // check if there's anything to scroll in the first place
            if (scroller.length > 0) {
                scroller = scroller.eq(0);

                var dim = {
                    e: dimensions(el),
                    s: dimensions(scroller)
                };

                var rel = {
                    top: dim.e.rect.top - (dim.s.rect.top + dim.s.border.top),
                    bottom: dim.s.rect.bottom - dim.s.border.bottom - dim.s.scrollbar.bottom - dim.e.rect.bottom,
                    left: dim.e.rect.left - (dim.s.rect.left + dim.s.border.left),
                    right: dim.s.rect.right - dim.s.border.right - dim.s.scrollbar.right - dim.e.rect.right
                };

                var animOptions = {};

                // vertical scroll
                if (options.direction.y === true) {
                    if (rel.top < 0) {
                        animOptions.scrollTop = dim.s.scroll.top + rel.top;
                        scroller.scrollTop = dim.s.scroll.top + rel.top;
                    }
                    else if (rel.top > 0 && rel.bottom < 0) {
                        animOptions.scrollTop = dim.s.scroll.top + Math.min(rel.top, -rel.bottom);
                        scroller.scrollTop = dim.s.scroll.top + Math.min(rel.top, -rel.bottom);
                    }
                }

                // horizontal scroll
                if (options.direction.x === true) {
                    if (rel.left < 0) {
                        animOptions.scrollLeft = dim.s.scroll.left + rel.left;
                        scroller.scrollLeft = dim.s.scroll.left + rel.left;
                    }
                    else if (rel.left > 0 && rel.right < 0) {
                        animOptions.scrollLeft = dim.s.scroll.left + Math.min(rel.left, -rel.right);
                        scroller.scrollLeft = dim.s.scroll.left + Math.min(rel.left, -rel.right);
                    }
                }

                // scroll if needed

                if (!$.isEmptyObject(animOptions)) {
                    if (rootrx.test(scroller[0].nodeName)) {
                        scroller = $("html,body");
                    }

                    if (!options.activeanime) {
                        $(scroller).scrollTop(animOptions.scrollTop);
                        $(scroller).scrollLeft(animOptions.scrollLeft);
                    }
                    else {
                        scroller
                            .animate(animOptions, options.duration)
                            .eq(0) // we want function to be called just once (ref. "html,body")
                            .queue(function (next) {
                                $.isFunction(options.complete) && options.complete.call(scroller[0]);
                                next();
                            });
                    }
                }
                else {
                    // when there's nothing to scroll, just call the "complete" function
                    $.isFunction(options.complete) && options.complete.call(scroller[0]);
                }
            }

            // return set back
            return this;
        }
    });

    var scrollValue = {
        auto: true,
        scroll: true,
        visible: false,
        hidden: false
    };

    $.extend($.expr[":"], {
        scrollable: function (element, index, meta, stack) {
            var direction = converter[typeof (meta[3]) === "string" && meta[3].toLowerCase()] || converter.both;
            var styles = (document.defaultView && document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(element, null) : element.currentStyle);
            var overflow = {
                x: scrollValue[styles.overflowX.toLowerCase()] || false,
                y: scrollValue[styles.overflowY.toLowerCase()] || false,
                isRoot: rootrx.test(element.nodeName)
            };

            // check if completely unscrollable (exclude HTML element because it's special)
            if (!overflow.x && !overflow.y && !overflow.isRoot) {
                return false;
            }

            var size = {
                height: {
                    scroll: element.scrollHeight,
                    client: element.clientHeight
                },
                width: {
                    scroll: element.scrollWidth,
                    client: element.clientWidth
                },
                // check overflow.x/y because iPad (and possibly other tablets) don't dislay scrollbars
                scrollableX: function () {
                    return (overflow.x || overflow.isRoot) && this.width.scroll > this.width.client;
                },
                scrollableY: function () {
                    return (overflow.y || overflow.isRoot) && this.height.scroll > this.height.client;
                }
            };
            return direction.y && size.scrollableY() || direction.x && size.scrollableX();
        }
    });
})(jQuery);
